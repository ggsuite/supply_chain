<!-- Don't edit. Generated by readme_test.dart -->
# Supply Chain - Data Flow & State Management

Supply Chain (SC) is a data flow and state management framework.

## Features

- ✅ Efficiently manage application state
- ✅ Visualize application data flow & dependencies
- ✅ Smoothly animate state transitions
- ✅ Efficient processing using caching and priorization
- ✅ Prevent unneccessary updates
- ✅ Query nodes and scopes
- ✅ Modify supply chains using plugins
- ✅ Create auto connecting smart nodes

## Concept

A customer `nodes` receive components from one or more supplier nodes. Each node
creates a `product`, that is delivered to customer nodes. The application state
is modelled as an supply chain. Nodes again are put into nested `scopes`. A
`supply chain manager` (SCM) coordinates the process.

<svg id="my-svg" width="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="flowchart" style="max-width: 409.578px; background-color: white;" viewBox="0 0 409.578125 140" role="graphics-document document" aria-roledescription="flowchart-v2"><style>#my-svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#my-svg .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-linecap:round;}#my-svg .edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#my-svg .error-icon{fill:#552222;}#my-svg .error-text{fill:#552222;stroke:#552222;}#my-svg .edge-thickness-normal{stroke-width:1px;}#my-svg .edge-thickness-thick{stroke-width:3.5px;}#my-svg .edge-pattern-solid{stroke-dasharray:0;}#my-svg .edge-thickness-invisible{stroke-width:0;fill:none;}#my-svg .edge-pattern-dashed{stroke-dasharray:3;}#my-svg .edge-pattern-dotted{stroke-dasharray:2;}#my-svg .marker{fill:#333333;stroke:#333333;}#my-svg .marker.cross{stroke:#333333;}#my-svg svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#my-svg p{margin:0;}#my-svg .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#333;}#my-svg .cluster-label text{fill:#333;}#my-svg .cluster-label span{color:#333;}#my-svg .cluster-label span p{background-color:transparent;}#my-svg .label text,#my-svg span{fill:#333;color:#333;}#my-svg .node rect,#my-svg .node circle,#my-svg .node ellipse,#my-svg .node polygon,#my-svg .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#my-svg .rough-node .label text,#my-svg .node .label text,#my-svg .image-shape .label,#my-svg .icon-shape .label{text-anchor:middle;}#my-svg .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#my-svg .rough-node .label,#my-svg .node .label,#my-svg .image-shape .label,#my-svg .icon-shape .label{text-align:center;}#my-svg .node.clickable{cursor:pointer;}#my-svg .root .anchor path{fill:#333333!important;stroke-width:0;stroke:#333333;}#my-svg .arrowheadPath{fill:#333333;}#my-svg .edgePath .path{stroke:#333333;stroke-width:2.0px;}#my-svg .flowchart-link{stroke:#333333;fill:none;}#my-svg .edgeLabel{background-color:rgba(232,232,232, 0.8);text-align:center;}#my-svg .edgeLabel p{background-color:rgba(232,232,232, 0.8);}#my-svg .edgeLabel rect{opacity:0.5;background-color:rgba(232,232,232, 0.8);fill:rgba(232,232,232, 0.8);}#my-svg .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#my-svg .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#my-svg .cluster text{fill:#333;}#my-svg .cluster span{color:#333;}#my-svg div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#my-svg .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#my-svg rect.text{fill:none;stroke-width:0;}#my-svg .icon-shape,#my-svg .image-shape{background-color:rgba(232,232,232, 0.8);text-align:center;}#my-svg .icon-shape p,#my-svg .image-shape p{background-color:rgba(232,232,232, 0.8);padding:2px;}#my-svg .icon-shape rect,#my-svg .image-shape rect{opacity:0.5;background-color:rgba(232,232,232, 0.8);fill:rgba(232,232,232, 0.8);}#my-svg .label-icon{display:inline-block;height:1em;overflow:visible;vertical-align:-0.125em;}#my-svg .node .label-icon path{fill:currentColor;stroke:revert;stroke-width:revert;}#my-svg :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}#my-svg .highlight&gt;\*{fill:#FFFFAA!important;stroke:#333!important;}#my-svg .highlight span{fill:#FFFFAA!important;stroke:#333!important;}</style><g><marker id="my-svg_flowchart-v2-pointEnd" class="marker flowchart-v2" viewBox="0 0 10 10" refX="5" refY="5" markerUnits="userSpaceOnUse" markerWidth="8" markerHeight="8" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"/></marker><marker id="my-svg_flowchart-v2-pointStart" class="marker flowchart-v2" viewBox="0 0 10 10" refX="4.5" refY="5" markerUnits="userSpaceOnUse" markerWidth="8" markerHeight="8" orient="auto"><path d="M 0 5 L 10 10 L 10 0 z" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"/></marker><marker id="my-svg_flowchart-v2-circleEnd" class="marker flowchart-v2" viewBox="0 0 10 10" refX="11" refY="5" markerUnits="userSpaceOnUse" markerWidth="11" markerHeight="11" orient="auto"><circle cx="5" cy="5" r="5" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"/></marker><marker id="my-svg_flowchart-v2-circleStart" class="marker flowchart-v2" viewBox="0 0 10 10" refX="-1" refY="5" markerUnits="userSpaceOnUse" markerWidth="11" markerHeight="11" orient="auto"><circle cx="5" cy="5" r="5" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"/></marker><marker id="my-svg_flowchart-v2-crossEnd" class="marker cross flowchart-v2" viewBox="0 0 11 11" refX="12" refY="5.2" markerUnits="userSpaceOnUse" markerWidth="11" markerHeight="11" orient="auto"><path d="M 1,1 l 9,9 M 10,1 l -9,9" class="arrowMarkerPath" style="stroke-width: 2; stroke-dasharray: 1, 0;"/></marker><marker id="my-svg_flowchart-v2-crossStart" class="marker cross flowchart-v2" viewBox="0 0 11 11" refX="-1" refY="5.2" markerUnits="userSpaceOnUse" markerWidth="11" markerHeight="11" orient="auto"><path d="M 1,1 l 9,9 M 10,1 l -9,9" class="arrowMarkerPath" style="stroke-width: 2; stroke-dasharray: 1, 0;"/></marker><g class="root"><g class="clusters"/><g class="edgePaths"/><g class="edgeLabels"/><g class="nodes"><g class="root" transform="translate(0, 0)"><g class="clusters"><g class="cluster" id="scope_4" data-look="classic"><rect style="" x="8" y="8" width="393.578125" height="124"/><g class="cluster-label" transform="translate(184.4765625, 8)"><foreignObject width="40.625" height="24"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel"><p>scope</p></span></div></foreignObject></g></g></g><g class="edgePaths"><path d="M162.781,70L169.031,70C175.281,70,187.781,70,199.615,70C211.448,70,222.615,70,228.198,70L233.781,70" id="L_supplier_0_customer_1_0" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" style=";" data-edge="true" data-et="edge" data-id="L_supplier_0_customer_1_0" data-points="W3sieCI6MTYyLjc4MTI1LCJ5Ijo3MH0seyJ4IjoyMDAuMjgxMjUsInkiOjcwfSx7IngiOjIzNy43ODEyNSwieSI6NzB9XQ==" marker-end="url(#my-svg_flowchart-v2-pointEnd)"/></g><g class="edgeLabels"><g class="edgeLabel"><g class="label" data-id="L_supplier_0_customer_1_0" transform="translate(0, 0)"><foreignObject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" class="labelBkg" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel"></span></div></foreignObject></g></g></g><g class="nodes"><g class="node default" id="flowchart-supplier_0-0" transform="translate(104.140625, 70)"><rect class="basic label-container" style="" x="-58.640625" y="-27" width="117.28125" height="54"/><g class="label" style="" transform="translate(-28.640625, -12)"><rect/><foreignObject width="57.28125" height="24"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel"><p>supplier</p></span></div></foreignObject></g></g><g class="node default" id="flowchart-customer_1-1" transform="translate(300.9296875, 70)"><rect class="basic label-container" style="" x="-63.1484375" y="-27" width="126.296875" height="54"/><g class="label" style="" transform="translate(-33.1484375, -12)"><rect/><foreignObject width="66.296875" height="24"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel"><p>customer</p></span></div></foreignObject></g></g></g></g></g></g></g></svg>

## Basics

```dart
// @license
// Copyright (c) ggsuite
//
// Use of this source code is governed by terms that can be
// found in the LICENSE file in the root of this package.

import 'package:gg_golden/gg_golden.dart';
import 'package:supply_chain/supply_chain.dart';
import 'package:test/test.dart';

void main() {
  test('Basic Tutorial', () async {
    // .............................
    // Create a supply chain manager
    // Setting isTest to true will apply all changes
    // once flush is called
    final scm = Scm(isTest: true);

    // ...................
    // Create a root scope
    final rootScope = Scope.root(key: 'root', scm: scm);

    // Create a main scope
    const scopeBp = ScopeBluePrint(key: 'scope');
    final scope = scopeBp.instantiate(scope: rootScope);

    // ......................
    // Create a supplier node

    // First create a blue print
    const supplierBp = NodeBluePrint<int>(initialProduct: 1, key: 'supplier');

    // Instantiate the blue print
    final supplier = supplierBp.instantiate(scope: scope);

    // ......................
    // Create a customer node
    // doubling the product of the supplier
    final customerBp = NodeBluePrint<int>(
      key: 'customer',
      initialProduct: 1,
      suppliers: ['supplier'],
      produce: (components, previousProduct, node) {
        final supplier = components[0] as int;
        return supplier * 2;
      },
    );

    final customer = customerBp.instantiate(scope: scope);

    // .................
    // Apply all changes
    scm.flush();

    // ......................
    // The customer has doubled the product of the supplier
    expect(supplier.product, 1);
    expect(customer.product, 1 * 2);

    // ........................
    // Change and apply changes

    // Change the supplier value
    supplier.product = 5;

    // Apply the changes
    scm.flush();

    // The customer value is also changed
    expect(supplier.product, 5);
    expect(customer.product, 5 * 2);

    // .............
    // Search a node just using the key. The first found scope is returned.
    final foundCustomer = rootScope.findNode<int>('customer');
    expect(foundCustomer, customer);

    // Add more context to be more precise
    final foundCustomer1 = rootScope.findNode<int>('scope/customer');
    expect(foundCustomer1, customer);

    // Use the complete path to find a very special node
    final foundCustomer2 = rootScope.findNode<int>('root/scope/customer');
    expect(foundCustomer2, customer);

    // If a node cannot be found, findNode returns null
    final foundCustomer3 = rootScope.findNode<int>('xyz');
    expect(foundCustomer3, isNull);

    // In the same way scopes can be searched
    final foundScope = customer.scope.findScope('scope');
    expect(foundScope, scope);

    // ..........................
    // Print node and scope graph
    final graph = scope.mermaid();
    await writeGolden(fileName: 'basic_01.mmd', data: graph);

    // ...............................
    // Show all node pathes of a scope
    final allNodePathes = rootScope.ls();
    await writeGolden(fileName: 'all_node_pathes.json', data: allNodePathes);
    expect(allNodePathes, ['scope', 'scope/supplier', 'scope/customer']);
  });
}

```

## Debugging

```dart
// @license
// Copyright (c) ggsuite
//
// Use of this source code is governed by terms that can be
// found in the LICENSE file in the root of this package.

import 'package:supply_chain/supply_chain.dart';
import 'package:test/test.dart';

void main() {
  test('Debugging Tutorial', () async {
    // Create a supply chain
    final main = Scope.example();
    final scm = main.scm;

    // Create a supplier that delivers an int
    final supplier = const NodeBluePrint(
      key: 'supplier',
      initialProduct: 1,
    ).instantiate(scope: main);

    // Create a producer blue print which doubles the value provided by supplier
    final producer = NodeBluePrint(
      key: 'producer',
      initialProduct: 0,
      suppliers: ['supplier'],
      produce: (components, previousProduct, node) {
        final [int val] = components;
        return val * 2;
      },
    );

    // Create three child scopes within main
    final child0 = const ScopeBluePrint(key: 'child0').instantiate(scope: main);
    final child1 = const ScopeBluePrint(key: 'child1').instantiate(scope: main);
    final child2 = const ScopeBluePrint(key: 'child2').instantiate(scope: main);

    // Within each of the child scope, instantiate a producer
    final producer0 = producer.instantiate(scope: child0);
    final producer1 = producer.instantiate(scope: child1);
    final producer2 = producer.instantiate(scope: child2);

    // Apply all changes
    scm.flush();

    // Now all producers will have the supplier doubled value
    expect(supplier.product, 1);
    expect(producer0.product, 2);
    expect(producer1.product, 2);
    expect(producer2.product, 2);

    // Place a breakpoint in the produce function at the line "return val * 2;"
    // Run this test in debugging mode.
    // The breakpoint will stop three times, for producer0, 1 and 2.

    // How can you make sure, that the breakpoint only stops for producer1?

    // 1. List all node paths of the supply chain.
    final paths = main.ls();
    expect(paths, [
      'child0',
      'child0/producer',
      'child1',
      'child1/producer',
      'child2',
      'child2/producer',
      'supplier',
    ]);

    // 2. Identify the path of producer1, i.e. "child1/producer"

    // 3. Edit the breakpoint created before and add the following condition:
    // node.path.contains('child1/producer')

    // 4. Re-run the tests in debugging node. The debugger now will stop only
    // on producer1. Print "node.path" to see if this is true.
  });
}

```

## Features and bugs

Please file feature requests and bugs at [GitHub](https://github.com/ggsuite/supply_chain).
